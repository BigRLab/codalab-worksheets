{% extends "base.html" %}

{% block head_title %}Experiment details{% endblock head_title %}
{% block page_title %}Experiment details{% endblock page_title %}

{% block content %}
<div class="large-9 large-centered columns content">
    <div id="worksheet-message">
        Loading worksheet...
    </div>
    <div id="worksheet-body">
        <div id="worksheet-content">
        </div>
    </div>
</div>
{% endblock %}

{% block jsincludes %}
<script src="{{ STATIC_URL }}js/markdown.min.js"></script>
<script type="text/javascript"
  src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
MathJax.Hub.Config({
    tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea']
    }
});
MathJax.Hub.Queue(function() {
    // Fix <code> tags after MathJax finishes running. This is a
    // hack to overcome a shortcoming of Markdown. Discussion at
    // https://github.com/mojombo/jekyll/issues/199
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});

var WorksheetRenderer = (function () {
    WorksheetRenderer.prototype.renderBundle = function (data) {
        var lines = [
            "> type: " + data.bundle_type,
            "> uuid:" + data.uuid,
            "> state: " + data.state,
            "> metadata > name: " + data.metadata.name,
            "> metadata > description: " + data.metadata.description,
            "> metadata > created: " + data.metadata.created,
            "> metadata > size: " + data.metadata.data_size,
            "> metadata > tags: " + data.metadata.tags,
            "> browse"
        ];
        return markdown.toHTML(lines.join('\n\n'));
    };
    function WorksheetRenderer(element, data) {
        if (data && data.items && Array.isArray(data.items)) {
            var _this = this;
            blocks = data.items.map(function (item) {
                if (item[0] === null) {
                    return markdown.toHTML(item[1]);
                }
                return _this.renderBundle(item[0]); 
            });
            element.innerHTML = blocks.join('\n');
            MathJax.Hub.Queue(["Typeset", MathJax.Hub, "worksheet-content"]);
        }
    }
    return WorksheetRenderer;
})();

$(document).ready(function() {
    $.ajax({
        type: "GET",
        url: "/api" + document.location.pathname,
        cache: false,
        success: function (data) {
            new WorksheetRenderer($("#worksheet-content").get(0), data);
            $("#worksheet-message").hide();
        },
        error: function (xhr, status, err) {
            if (xhr.status == 404) {
                $("#worksheet-message").html("Experiment was not found.");
            } else {
                $("#worksheet-message").html("An error occurred. Please try refreshing the page.");
            }
        }
    });
});
</script>
{% endblock jsincludes %}
